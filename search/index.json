[{"content":"rbenv는 설치된 모든 버전의 ruby를 ~/.rbenv/versions 디렉토리 아래에 둔다.\nrbenv init rbenv init - 명령어를 실행하면 rbenv의 초기화 스크립트가 출력된다.\n$ rbenv init - export PATH=\u0026#34;/Users/zzulu/.rbenv/shims:${PATH}\u0026#34; export RBENV_SHELL=bash source \u0026#39;/usr/local/Cellar/rbenv/1.1.1/libexec/../completions/rbenv.bash\u0026#39; command rbenv rehash 2\u0026gt;/dev/null rbenv() { local command command=\u0026#34;$1\u0026#34; if [ \u0026#34;$#\u0026#34; -gt 0 ]; then shift fi case \u0026#34;$command\u0026#34; in rehash|shell) eval \u0026#34;$(rbenv \u0026#34;sh-$command\u0026#34; \u0026#34;$@\u0026#34;)\u0026#34;;; *) command rbenv \u0026#34;$command\u0026#34; \u0026#34;$@\u0026#34;;; esac } 따라서 eval \u0026quot;$(rbenv init –)\u0026quot; 명령어를 통해서 rbenv의 초기화 스크립트를 실행한다. rbenv를 사용하기 위해서는 초기화가 항상 필요하므로, ~/.bash_profile에 아래의 내용을 작성하여 터미널이 실행될 때 마다 rbenv의 초기화가 진행되도록 한다.\nif which rbenv \u0026gt; /dev/null; then eval \u0026#34;$(rbenv init -)\u0026#34;; fi shims shim에 대한 위키피디아의 정의는 다음과 같다.\n In computer programming, a shim is a small library that transparently intercepts API calls and changes the arguments passed, handles the operation itself, or redirects the operation elsewhere.\n rbenv는 ~/.rbenv/shims 디렉토리가 존재하며, 환경변수 PATH의 제일 앞에 이 경로를 추가함으로써 터미널에서 실행되는 명령어가 rbenv의 관리하에 있는 ruby 명령어일 경우 rbenv가 intercept 할 수 있도록 한다. 따라서 ruby -v 명령어를 실행하게 되면, ~/.rbenv/shims 디렉토리에서 shim script인 ruby를 찾고, 실행하게 된다.\n~/.rbenv/shims 디렉토리에 있는 실행 파일들의 내용을 보면 모두가 아래와 같은 동일한 쉘 스크립트 코드를 가지고 있다. ~/.rbenv/shims/rails든 ~/.rbenv/shims/bundler든 모두 같은 코드를 가지고 있다.\n#!/usr/bin/env bash set -e [ -n \u0026#34;$RBENV_DEBUG\u0026#34; ] \u0026amp;\u0026amp; set -x program=\u0026#34;${0##*/}\u0026#34; if [ \u0026#34;$program\u0026#34; = \u0026#34;ruby\u0026#34; ]; then for arg; do case \u0026#34;$arg\u0026#34; in -e* | -- ) break ;; */* ) if [ -f \u0026#34;$arg\u0026#34; ]; then export RBENV_DIR=\u0026#34;${arg%/*}\u0026#34; break fi ;; esac done fi export RBENV_ROOT=\u0026#34;/Users/zzulu/.rbenv\u0026#34; exec \u0026#34;/usr/local/Cellar/rbenv/1.1.1/libexec/rbenv\u0026#34; exec \u0026#34;$program\u0026#34; \u0026#34;$@\u0026#34; shim 파일 자체로는 많은 일을 하지 않는다. 환경 변수 RBENV_DIR와 RBENV_ROOT를 설정하고, /usr/local/Cellar/rbenv/1.0.0/libexec/rbenv exec [original-command] [original-args] 명령어를 실행한다. 따라서 rails s를 명령어를 입력하면 ~/.rbenv/shims/rails가 실행이 되는 것이고, 실제로는 rbenv exec rails s가 실행되는 것이다.\nrbenv exec rbenv exec는 현재 사용중인 ruby 버전의 bin 디렉토리가 제일 앞에 오도록 환경 변수 PATH를 설정하여 script 파일을 실행하도록 한다.\nrbenv exec rails s를 실행하게 되면 다음과 같은 과정을 거쳐 실행된다.\n 어떤 버전의 ruby를 사용할 지 찾는다. rbenv version-name 명령어를 입력하면 현재 위치에서 사용하게 되는 ruby 버전을 보여주는데 이 버전을 사용한다. (rbenv가 ruby 버전을 찾는 순서)  RBENV_VERSION=2.4.1 어떤 명령어를 실행할지 exec script의 첫 argument에서 찾는다. rbenv exec rails s를 실행했으므로 지금 상황에서는 rails 명령어를 나타낸다.  RBENV_COMMAND=rails rbenv which 명령어 실행하여 실행될 명령어가 있는 path를 찾는다. rbenv which rails 명령어를 입력하면 path를 보여주는데 이 path를 사용한다.  $ rbenv which rails /Users/zzulu/.rbenv/versions/2.4.1/bin/rails RBENV_COMMAND_PATH=/Users/zzulu/.rbenv/versions/2.4.1/bin/rails RBENV_COMMAND_PATH로부터 RBENV_BIN_PATH를 생성하여 환경 변수 PATH의 앞에 붙인다.  RBENV_BIN_PATH=/Users/shot/.rbenv/versions/2.4.1/bin export PATH=\u0026#34;${RBENV_BIN_PATH}:${PATH}\u0026#34; 최종적으로 원본 명령어가 실행된다. 시스템은 shim이 아닌 원래의 binary를 찾아 실행한다.  rails s 요약하자면 rbenv exec rails s 명령어를 실행하면, rbenv exec가 명령어를 PATH=\u0026quot;~/.rbenv/versions/2.4.1/bin:$PATH\u0026quot; rails s로 변경하여 실행하게 된다.\nrbenv rehash rbenv rehash는 ~/.rbenv/shims 디렉토리에 shim script를 만들어주는 명령어이다.\n이 명령어의 실행결과로 ~/.rbenv/versions/[ruby-version]/bin 디렉토리의 각 파일명과 동일한 쉘 스크립트 파일이 ~/.rbenv/shims 디렉토리에 생성된다.\n새로운 젬을 추가(gem install rails) 또는 삭제(gem uninstall rails)한 후에는 rbenv rehash 명령어가 실행되어 현재의 ruby 버전의 실행 파일들(~/.rbenv/versions/[current-version]/bin/ 디렉토리 안의 스크립트들)의 이름과 동일한 shim script 파일들을 ~/.rbenv/shims 디렉토리에 생성한다. (오래된 버전의 rbenv는 자동으로 이 작업을 해주지 않아 따로 plugin이 존재했었다. 그러나 지금은 자동으로 해준다.)\nshim들이 생성되는 상세한 과정은 다음과 같다.\n  ~/.rbenv/shims 디렉토리가 존재하는지 확인한다. 만약에 디렉토리가 없다면 생성한다.\n  shim prototype 파일인 ~/.rbenv/shims/.rbenv-shim이 존재하는지 확인한다. 만약에 존재한다면 다른 곳에서 rehash가 진행되고 있다는 의미이므로 현재 진행중인 rehash를 종료한다.\n  .rbenv-shim 파일이 없다면 생성하여, 다른 rehash 작업이 방해하지 못하도록 한다. 그리고는 위에서 보았던 shim script의 내용을 prototype 파일에 작성한다.\n  설치된 ruby 버전의 모든 bin 디렉토리를 탐색하여 해당 디렉토리에 존재하는 스크립트의 이름과 동일한 이름의 shim script를 ~/.rbenv/shims 디렉토리에 생성하고, prototype 파일에 작성된 내용을 shim script에 복사한다. 모든 shim script는 같은 내용으로 작성된다.\n  마지막으로 prototype 파일을 삭제한다.\n  ","date":"2021-01-28T15:53:00+09:00","permalink":"https://notes.hphk.io/p/how-rbenv-works/","title":"rbenv의 동작 원리"},{"content":"rbenv는 아래의 순서대로 루비 버전을 찾는다. [version]은 2.4.4와 같은 형식을 사용한다.\n  RBENV_VERSION 환경 변수에 설정된 ruby version을 사용한다. rbenv shell [version] 명령어로 설정할 수 있다.\n  실행하고자 하는 스크립트 파일이 위치하는 현재 디렉토리와 상위 디렉토리의 계층 구조를 따라 가면서 찾게 되는 .ruby-version 파일의 버전을 인식한다. 이 과정은 루트 디렉토리까지 진행된다. .ruby-version 파일은 rbenv local [version] 명령어로 생성할 수 있다.\n  전역 version 파일인 ~/.rbenv/version 파일을 참조하여 ruby version을 인식한다. 이 파일은 rbenv global [version] 명령어로 생성할 수 있다.\n  rbenv version 명령어를 터미널에서 입력해보면 어디서 설정된 ruby 버전인지 확인 가능하다.\n$ rbenv version # shell 2.4.1 (set by RBENV_VERSION environment variable) # local 2.4.1 (set by /Users/zzulu/Codes/Rails/rubychatbot/.ruby-version) # global 2.4.1 (set by /Users/zzulu/.rbenv/version) ","date":"2021-01-28T15:50:00+09:00","permalink":"https://notes.hphk.io/p/detecting-ruby-version-in-rbenv/","title":"rbenv가 ruby 버전을 찾는 순서"},{"content":" Git Bash가 설치되어 있어야 합니다.\n 1. Windows Terminal 설치 Microsoft Store에서 Windows Terminal을 설치합니다.\n Microsoft Store - Windows Terminal \n2. Windows Terminal 실행 처음 실행하면 기본으로 PowerShell, CMD, Azure Cloud Shell을 사용할 수 있도록 되어 있습니다.\n Windows Terminal shell list \n설정을 통해 추가적인 Shell(Bash)을 사용할 수 있도록 해봅시다.\n3. Windows Terminal 설정 설정 메뉴를 클릭하거나 ctrl + , 단축키를 사용하여, 설정 파일을 열 수 있습니다.\n settings.json \n메모장으로 열리기 때문에 편집이 불편할 수 있습니다. 다른 에디터를 사용하실 분들은 다른 이름으로 저장 메뉴 또는 ctrl + shift + s 단축키를 사용하여 \u0026lsquo;다른 이름으로 저장\u0026rsquo; 창을 열고, 해당 위치를 원하는 에디터로 열어 설정 파일을 편집합니다. 여기서는 VS Code를 사용하겠습니다. Code로 열기 컨텍스트 메뉴를 통해 VS Code에서 설정 파일이 존재하는 폴더를 열어 줍니다.\n Open with VS Code \nprofiles 항목에 Git Bash 프로필을 추가합니다.\n{ \u0026#34;profiles\u0026#34;: { \u0026#34;defaults\u0026#34;: { }, \u0026#34;list\u0026#34;: [ { \u0026#34;guid\u0026#34;: \u0026#34;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Windows PowerShell\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;powershell.exe\u0026#34;, \u0026#34;hidden\u0026#34;: false }, { \u0026#34;guid\u0026#34;: \u0026#34;{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;명령 프롬프트\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;cmd.exe\u0026#34;, \u0026#34;hidden\u0026#34;: false }, { \u0026#34;guid\u0026#34;: \u0026#34;{b453ae62-4e3d-5e58-b989-0a998ec441b8}\u0026#34;, \u0026#34;hidden\u0026#34;: false, \u0026#34;name\u0026#34;: \u0026#34;Azure Cloud Shell\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;Windows.Terminal.Azure\u0026#34; }, { \u0026#34;guid\u0026#34;: \u0026#34;{124fc1da-dadc-4276-9c4e-f0524ba57a49}\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Git Bash\u0026#34;, \u0026#34;commandline\u0026#34;: \u0026#34;\\\u0026#34;%PROGRAMFILES%\\\\git\\\\usr\\\\bin\\\\bash.exe\\\u0026#34; -i -l\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;%PROGRAMFILES%\\\\git\\\\mingw64\\\\share\\\\git\\\\git-for-windows.ico\u0026#34;, \u0026#34;startingDirectory\u0026#34;: \u0026#34;%USERPROFILE%\u0026#34;, \u0026#34;cursorShape\u0026#34;: \u0026#34;filledBox\u0026#34;, \u0026#34;hidden\u0026#34;: false } ] }, } 이 때 프로필의 guid는 해당 프로필의 고유 아이디이며, 저 포멧을 사용하고 다른 값과 중복되지만 않으면 어떠한 값도 사용 가능합니다. 위의 guid를 그대로 사용해도 되지만, 새롭게 생성하고 싶으신 분들은 PowerShell에서 아래의 명령어를 입력하여 새롭게 생성할 수 있습니다.\n[guid]::NewGuid()  Generate new guid \n다양한 프로필 설정법은 https://aka.ms/terminal-profile-settings 에서 확인 가능합니다.\n저장을 하고 나면 아래와 같이 Git Bash가 추가된 것을 확인할 수 있습니다.\n Git Bash on shell list   Git Bash with Windows Terminal \n4. 기본 프로필 설정 새 탭을 열었을 때 기본으로 나오는 프로필을 변경하려면, 기본으로 설정하고자 하는 프로필의 guid를 defaultProfile 키의 값으로 지정하면 됩니다.\n{ \u0026#34;defaultProfile\u0026#34;: \u0026#34;{124fc1da-dadc-4276-9c4e-f0524ba57a49}\u0026#34;, } ","date":"2021-01-21T15:10:00+09:00","image":"https://notes.hphk.io/p/git-bash-with-windows-terminal/images/windows-terminal.jpeg","permalink":"https://notes.hphk.io/p/git-bash-with-windows-terminal/","title":"Windows Terminal에서 Git Bash 사용하기"},{"content":"Arrow function이와 function 키워드의 가장 큰 차이점은 this 의 차이이다.\n1. 왜 이벤트 리스너에서 일반적으로 arrow function을 사용하면 안될까? \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;function\u0026#34;\u0026gt;function\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;arrow\u0026#34;\u0026gt;arrow function\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const functionButton = document.querySelector(\u0026#39;#function\u0026#39;) const arrowButton = document.querySelector(\u0026#39;#arrow\u0026#39;) functionButton.addEventListener(\u0026#39;click\u0026#39;, function (event) { console.log(\u0026#39;=====function=====\u0026#39;) console.log(this) }) arrowButton.addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; { console.log(\u0026#39;=====arrow fuction=====\u0026#39;) console.log(this) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 각각의 버튼을 눌러서 확인을 해보자.\n=====function===== \u0026lt;button id=\u0026#34;function\u0026#34;\u0026gt;function\u0026lt;/button\u0026gt; =====arrow fuction===== Window 2. this 자바스크립트의 this는 일반적인 프로그래밍 언어에서의 this와 조금 다르게 동작한다.\njava this와 python self의 인스턴스의 호출한 대상의 현재 객체를 뜻하는 것(참조)이었다.\n자바스크립트의 function 키워드 함수에서는 함수가 어떻게 호출 되었는지에 따라 다르게 동작한다. (동적으로 결정)\n브라우저 콘솔에 this를 입력 해보자.\n 브라우저 콘솔과 this \n2-1. window : 함수 호출, 함수 내 함수 window는 브라우저에서의 최상위 객체를 의미한다. (전역 객체)\n기본적인 함수 선언을 하고 호출한다면, 이 경우에는 전역에서 호출 하였으므로 전역 객체가 바인딩된다.\nconst greeting = function() { console.log(this) } greeting() // window 함수 내 함수는 추후에 다루겠다.\n2-2. 객체 : 메소드 호출 메소드로 선언하고 호출한다면, 오브젝트의 메소드이므로 오브젝트가 바인딩된다.\nconst you = { name: \u0026#39;neo\u0026#39;, greeting } you.greeting() // {name: \u0026#39;neo\u0026#39;, greeting: f} : this는 해당 오브젝트(객체) 2-3. Arrow Function arrow function에서의 this는 어떻게 동작할까?\narrow function에서는 호출과 위치와 상관없이 상위 스코프 this를 가리킨다. (Lexical this)\n따라서, 메소드 선언을 arrow 함수로 하게 된다면, 해당 오브젝트의 상위 스코프인 전역 객체인 window가 바인딩된다.\nconst arrowGreeting = () =\u0026gt; { console.log(this) } const me = { name: \u0026#39;me\u0026#39;, arrowGreeting } arrowGreeting() // window me.arrowGreeting() // window 메소드 선언은 function 키워드를 활용하자!\n그러면 ES6에서 언제 arrow function을 활용하면 편할까? const num = { numbers: [1], print: function () { console.log(this) // {numbers: Array(1), print: ƒ}  console.log(this.numbers) // [1]  this.numbers.forEach(function (num) { console.log(num) // 1  console.log(this) // window  }) } } num.print()  내부 함수에서는 어디든 상관 없이 항상 전역객체를 바인딩한다. 뒤에 이야기 한다고 했던 함수 내의 함수 상황의 예시가 위와 같다. 이때 arrow function을 쓰면 좋다! print 메소드의 내에 있는 콜백함수(forEach)에서의 상위 스코프는 num2 오브젝트이다. 따라서, this가 아래와 같이 해당 오브젝트가 바인딩 된다.  const num2 = { numbers: [1], print: function () { console.log(this) // {numbers: Array(1), print: ƒ}  console.log(this.numbers) // [1]  this.numbers.forEach(num =\u0026gt; { console.log(num) // 1  console.log(this) // {numbers: Array(1), print: ƒ}  }) } } num2.print() 다시 이벤트 리스너로 돌아와서, addEventListener 에서의 콜백 함수는 특별하게 function키워드의 경우에는 이벤트 리스너를 호출한 대상을 (event.target) 뜻한다. 따라서, 호출한 대상을 원한다면 this 를 활용할 수 있다.\n다만, arrow function의 경우 상위 스코프를 지칭하기 때문에 window 객체가 출력된 것이다.\n3. 정리 Arrow Function을 쓰면 안되는 대표적인 경우는 다음과 같다.\n  object의 메소드 정의\n this가 전역 객체(window)를 나타낸다.    생성자 함수\n  생성자 함수는 object를 생성하는 또다른 방법이다.\nconst MyInfo = { name: \u0026#39;tak\u0026#39;, phoneNumber : \u0026#39;010-1234-5678\u0026#39;, greeting() { console.log(this.name + \u0026#39;hi\u0026#39;) } } const Person = function (name) { this.name = name this.greeting = function() { console.log(this.name + \u0026#39;hi\u0026#39;) } } const justin = new Person(\u0026#39;justin\u0026#39;)   Arrow function을 사용하면 에러가 발생한다.\nconst Animal = name =\u0026gt; { this.name = name } const dog = new Animal(\u0026#39;dog\u0026#39;) // Uncaught TypeError: Animal is not a constructor     addEventListener 함수의 콜백 함수\n this가 전역 객체(window)를 나타낸다.    ","date":"2021-01-20T16:57:00+09:00","image":"https://notes.hphk.io/p/arrow-function-vs-regular-function/images/carbon.png","permalink":"https://notes.hphk.io/p/arrow-function-vs-regular-function/","title":"Arrow Function vs Regular Function"}]